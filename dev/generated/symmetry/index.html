<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>symmetry · CondensedMatterSOS</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CondensedMatterSOS</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../Benchmark_1/">Benchmark_1</a></li><li><a class="tocitem" href="../Glass/">Glass</a></li><li><a class="tocitem" href="../Ising/">Ising</a></li><li class="is-active"><a class="tocitem" href>symmetry</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>symmetry</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>symmetry</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/blegat/CondensedMatterSOS.jl/blob/master/examples/symmetry.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia">using SumOfSquares
include(joinpath(dirname(dirname(pathof(SumOfSquares))), &quot;examples&quot;, &quot;symmetry.jl&quot;))
include(joinpath(dirname(dirname(pathof(SumOfSquares))), &quot;examples&quot;, &quot;scaled_perm.jl&quot;))

struct KleinElement &lt;: GroupElement
    id::Int
end
Base.:(==)(a::KleinElement, b::KleinElement) = a.id == b.id

PermutationGroups.order(el::KleinElement) = iszero(el.id) ? 1 : 2
Base.inv(el::KleinElement) = el

function Base.:*(a::KleinElement, b::KleinElement)
    a.id &gt; b.id &amp;&amp; return b * a
    a.id == 0 &amp;&amp; return b
    a.id == b.id &amp;&amp; return one(a)
    a.id == 2 &amp;&amp; return KleinElement(1)
    b.id == 2 &amp;&amp; return KleinElement(3)
    return KleinElement(2)
end

Base.conj(a::KleinElement, b::KleinElement) = inv(b) * a * b
Base.:^(a::KleinElement, b::KleinElement) = conj(a, b)

struct KleinGroup &lt;: Group end
Base.one(::Union{KleinGroup, KleinElement}) = KleinElement(0)
PermutationGroups.gens(::KleinGroup) = [KleinElement(1), KleinElement(2)]
PermutationGroups.order(::Type{T}, G::KleinGroup) where {T} = convert(T, 4)
function Base.iterate(::KleinGroup, prev::KleinElement=KleinElement(-1))
    id = prev.id + 1
    if id &gt; 4
        return nothing
    else
        next = KleinElement(id)
        return next, next
    end
end

#SymbolicWedderburn.conjugacy_classes_orbit(KleinGroup())

function perm_klein(k::KleinElement, p::Perm)
    if k.id == 0
        return k
    else
        return KleinElement(k.id^p)
    end
end

&quot;&quot;&quot;
Group element `k * p = p * k^inv(p)`.
&quot;&quot;&quot;
struct KleinPermElement &lt;: GroupElement
    p::Perm{Int}
    k::KleinElement
end
Base.isone(el::KleinPermElement) = isone(el.k) &amp;&amp; isone(el.p)

function Base.hash(el::KleinPermElement, u::UInt64)
    return hash(el.k, hash(el.p, u))
end
function Base.:(==)(a::KleinPermElement, b::KleinPermElement)
    return a.p == b.p &amp;&amp; a.k == b.k
end</code></pre><p>k^(inv(p)) * inv(p) * k * p = k^(inv(p)) * k * inv(p) * p = 1</p><pre><code class="language-julia">function Base.inv(el::KleinPermElement)
    inv_p = inv(el.p)
    KleinPermElement(inv_p, perm_klein(el.k, inv_p))
end</code></pre><p>p * k * q * k&#39; = p * q * k^p * k&#39; k * p * k&#39; * q = k * k&#39;^p * p * q</p><pre><code class="language-julia">function Base.:*(a::KleinPermElement, b::KleinPermElement)
    return KleinPermElement(a.p * b.p, perm_klein(a.k, b.p) * b.k)
end
function Base.:^(el::KleinPermElement, k::Integer)
    return Base.power_by_squaring(el, k)
end

Base.conj(a::KleinPermElement, b::KleinPermElement) = inv(b) * a * b
Base.:^(a::KleinPermElement, b::KleinPermElement) = conj(a, b)

function PermutationGroups.order(el::KleinPermElement)
    cur = el
    i = 1
    while !isone(cur)
        i += 1
        cur *= el
    end
    return i
end

struct KleinPermGroup &lt;: Group end
Base.one(::Union{KleinPermGroup, KleinPermElement}) = KleinPermElement(Perm(3), one(KleinGroup()))
function PermutationGroups.gens(::KleinPermGroup)
    els = [KleinPermElement(Perm(3), KleinElement(1))]
    for g in gens(PermutationGroups.SymmetricGroup(3))
        push!(els, KleinPermElement(g, one(KleinGroup())))
    end
    return els
end
PermutationGroups.order(::Type{T}, G::KleinPermGroup) where {T} = convert(T, 6 * 4)
const P3 = collect(PermutationGroups.SymmetricGroup(3))
const IT = Iterators.product(1:6, 0:3)
function Base.iterate(::KleinPermGroup, args...)
    el_st = iterate(IT, args...)
    if el_st === nothing
        return nothing
    else
        el, st = el_st
        return KleinPermElement(P3[el[1]], KleinElement(el[2])), st
    end
end

struct CyclicElem &lt;: GroupElement
    n::Int
    id::Int
end
Base.:(==)(a::CyclicElem, b::CyclicElem) = a.n == b.n &amp;&amp; a.id == b.id
Base.inv(el::CyclicElem) = CyclicElem(el.n, (el.n - el.id) % el.n)

function Base.:*(a::CyclicElem, b::CyclicElem)
    return CyclicElem(a.n, (a.id + b.id) % a.n)
end
Base.:^(el::CyclicElem, k::Integer) = CyclicElem(el.n, (el.id * k) % el.n)

Base.conj(a::CyclicElem, b::CyclicElem) = inv(b) * a * b
Base.:^(a::CyclicElem, b::CyclicElem) = conj(a, b)

function PermutationGroups.order(el::CyclicElem)
    return div(el.n, gcd(el.n, el.id))
end

struct CyclicGroup &lt;: Group
    n::Int
end
Base.one(c::Union{CyclicGroup, CyclicElem}) = CyclicElem(c.n, 0)
PermutationGroups.gens(c::CyclicGroup) = [CyclicElem(c.n, 1)]
PermutationGroups.order(::Type{T}, c::CyclicGroup) where {T} = convert(T, c.n)
function Base.iterate(c::CyclicGroup, prev::CyclicElem=CyclicElem(c.n, -1))
    id = prev.id + 1
    if id &gt;= c.n
        return nothing
    else
        next = CyclicElem(c.n, id)
        return next, next
    end
end

#SymbolicWedderburn.conjugacy_classes_orbit(KleinPermGroup())

struct DirectSum &lt;: GroupElement
    c::CyclicElem
    k::KleinPermElement
end
function PermutationGroups.order(el::DirectSum)
    return lcm(PermutationGroups.order(el.c), PermutationGroups.order(el.k))
end

function Base.hash(el::DirectSum, u::UInt64)
    return hash(el.k, hash(el.c, u))
end
function Base.:(==)(a::DirectSum, b::DirectSum)
    return a.c == b.c &amp;&amp; a.k == b.k
end

function Base.inv(el::DirectSum)
    DirectSum(inv(el.c), inv(el.k))
end</code></pre><p>k * p * k&#39; * q = k * k&#39;^p * p * q</p><pre><code class="language-julia">function Base.:*(a::DirectSum, b::DirectSum)
    return DirectSum(a.c * b.c, a.k * b.k)
end
Base.:^(a::DirectSum, k::Integer) = DirectSum(a.c^k, a.k^k)

Base.conj(a::DirectSum, b::DirectSum) = inv(b) * a * b
Base.:^(a::DirectSum, b::DirectSum) = conj(a, b)

struct Lattice1Group &lt;: Group
    n::Int
end
Base.one(el::DirectSum) = DirectSum(one(el.c), one(el.k))
Base.one(L::Lattice1Group) = DirectSum(CyclicElem(L.n, 0), one(KleinPermGroup()))
function PermutationGroups.gens(L::Lattice1Group)
    els = DirectSum[]
    for g in gens(CyclicGroup(L.n))
        push!(els, DirectSum(g, one(KleinPermGroup())))
    end
    for g in gens(KleinPermGroup())
        push!(els, DirectSum(one(CyclicGroup(L.n)), g))
    end
    return els
end
PermutationGroups.order(L::Lattice1Group) = PermutationGroups.order(Int, L)
function PermutationGroups.order(::Type{T}, L::Lattice1Group) where {T}
    return order(T, CyclicGroup(L.n)) * order(T, KleinPermGroup())
end
Base.length(L::Lattice1Group) = PermutationGroups.order(L)
function Base.iterate(L::Lattice1Group)
    el_p, st_p = iterate(CyclicGroup(L.n))
    el_k, st_k = iterate(KleinPermGroup())
    return DirectSum(el_p, el_k), ((el_p, st_p), st_k)
end
function Base.iterate(L::Lattice1Group, st)
    el_st_k = iterate(KleinPermGroup(), st[2])
    if el_st_k === nothing
        el_st_p = iterate(CyclicGroup(L.n), st[1][2])
        el_st_p === nothing &amp;&amp; return nothing
        el_k, st_k = iterate(KleinPermGroup())
        return DirectSum(el_st_p[1], el_k), (el_st_p, st_k)
    end
    return DirectSum(st[1][1], el_st_k[1]), (st[1], el_st_k[2])
end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Ising/">« Ising</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 18 May 2021 12:57">Tuesday 18 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
